// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task_worker.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_task_5fworker_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_task_5fworker_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_task_5fworker_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_task_5fworker_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_task_5fworker_2eproto;
namespace task_worker {
class GeoPoint;
class GeoPointDefaultTypeInternal;
extern GeoPointDefaultTypeInternal _GeoPoint_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class PolygonResult;
class PolygonResultDefaultTypeInternal;
extern PolygonResultDefaultTypeInternal _PolygonResult_default_instance_;
class TaskRequest;
class TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
class TaskResponse;
class TaskResponseDefaultTypeInternal;
extern TaskResponseDefaultTypeInternal _TaskResponse_default_instance_;
}  // namespace task_worker
PROTOBUF_NAMESPACE_OPEN
template<> ::task_worker::GeoPoint* Arena::CreateMaybeMessage<::task_worker::GeoPoint>(Arena*);
template<> ::task_worker::Polygon* Arena::CreateMaybeMessage<::task_worker::Polygon>(Arena*);
template<> ::task_worker::PolygonResult* Arena::CreateMaybeMessage<::task_worker::PolygonResult>(Arena*);
template<> ::task_worker::TaskRequest* Arena::CreateMaybeMessage<::task_worker::TaskRequest>(Arena*);
template<> ::task_worker::TaskResponse* Arena::CreateMaybeMessage<::task_worker::TaskResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace task_worker {

enum TaskType : int {
  TRIANGULATION = 0,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = TRIANGULATION;
constexpr TaskType TaskType_MAX = TRIANGULATION;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    const std::string& name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
// ===================================================================

class GeoPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:task_worker.GeoPoint) */ {
 public:
  inline GeoPoint() : GeoPoint(nullptr) {};
  virtual ~GeoPoint();

  GeoPoint(const GeoPoint& from);
  GeoPoint(GeoPoint&& from) noexcept
    : GeoPoint() {
    *this = ::std::move(from);
  }

  inline GeoPoint& operator=(const GeoPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeoPoint& operator=(GeoPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GeoPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeoPoint* internal_default_instance() {
    return reinterpret_cast<const GeoPoint*>(
               &_GeoPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GeoPoint& a, GeoPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(GeoPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeoPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GeoPoint* New() const final {
    return CreateMaybeMessage<GeoPoint>(nullptr);
  }

  GeoPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GeoPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GeoPoint& from);
  void MergeFrom(const GeoPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GeoPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_worker.GeoPoint";
  }
  protected:
  explicit GeoPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_task_5fworker_2eproto);
    return ::descriptor_table_task_5fworker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLngFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // float lat = 1;
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lng = 2;
  void clear_lng();
  float lng() const;
  void set_lng(float value);
  private:
  float _internal_lng() const;
  void _internal_set_lng(float value);
  public:

  // float value = 3;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:task_worker.GeoPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float lat_;
  float lng_;
  float value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_task_5fworker_2eproto;
};
// -------------------------------------------------------------------

class TaskRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:task_worker.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {};
  virtual ~TaskRequest();

  TaskRequest(const TaskRequest& from);
  TaskRequest(TaskRequest&& from) noexcept
    : TaskRequest() {
    *this = ::std::move(from);
  }

  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
               &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TaskRequest& a, TaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskRequest* New() const final {
    return CreateMaybeMessage<TaskRequest>(nullptr);
  }

  TaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskRequest& from);
  void MergeFrom(const TaskRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_worker.TaskRequest";
  }
  protected:
  explicit TaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_task_5fworker_2eproto);
    return ::descriptor_table_task_5fworker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
  };
  // repeated .task_worker.GeoPoint points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::task_worker::GeoPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >*
      mutable_points();
  private:
  const ::task_worker::GeoPoint& _internal_points(int index) const;
  ::task_worker::GeoPoint* _internal_add_points();
  public:
  const ::task_worker::GeoPoint& points(int index) const;
  ::task_worker::GeoPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >&
      points() const;

  // .task_worker.TaskType task_type = 2;
  void clear_task_type();
  ::task_worker::TaskType task_type() const;
  void set_task_type(::task_worker::TaskType value);
  private:
  ::task_worker::TaskType _internal_task_type() const;
  void _internal_set_task_type(::task_worker::TaskType value);
  public:

  // @@protoc_insertion_point(class_scope:task_worker.TaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint > points_;
  int task_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_task_5fworker_2eproto;
};
// -------------------------------------------------------------------

class Polygon PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:task_worker.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {};
  virtual ~Polygon();

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(nullptr);
  }

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_worker.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_task_5fworker_2eproto);
    return ::descriptor_table_task_5fworker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kAreaFieldNumber = 2,
  };
  // repeated .task_worker.GeoPoint vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::task_worker::GeoPoint* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >*
      mutable_vertices();
  private:
  const ::task_worker::GeoPoint& _internal_vertices(int index) const;
  ::task_worker::GeoPoint* _internal_add_vertices();
  public:
  const ::task_worker::GeoPoint& vertices(int index) const;
  ::task_worker::GeoPoint* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >&
      vertices() const;

  // float area = 2;
  void clear_area();
  float area() const;
  void set_area(float value);
  private:
  float _internal_area() const;
  void _internal_set_area(float value);
  public:

  // @@protoc_insertion_point(class_scope:task_worker.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint > vertices_;
  float area_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_task_5fworker_2eproto;
};
// -------------------------------------------------------------------

class PolygonResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:task_worker.PolygonResult) */ {
 public:
  inline PolygonResult() : PolygonResult(nullptr) {};
  virtual ~PolygonResult();

  PolygonResult(const PolygonResult& from);
  PolygonResult(PolygonResult&& from) noexcept
    : PolygonResult() {
    *this = ::std::move(from);
  }

  inline PolygonResult& operator=(const PolygonResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolygonResult& operator=(PolygonResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PolygonResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PolygonResult* internal_default_instance() {
    return reinterpret_cast<const PolygonResult*>(
               &_PolygonResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PolygonResult& a, PolygonResult& b) {
    a.Swap(&b);
  }
  inline void Swap(PolygonResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolygonResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PolygonResult* New() const final {
    return CreateMaybeMessage<PolygonResult>(nullptr);
  }

  PolygonResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PolygonResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PolygonResult& from);
  void MergeFrom(const PolygonResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolygonResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_worker.PolygonResult";
  }
  protected:
  explicit PolygonResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_task_5fworker_2eproto);
    return ::descriptor_table_task_5fworker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonsFieldNumber = 1,
  };
  // repeated .task_worker.Polygon polygons = 1;
  int polygons_size() const;
  private:
  int _internal_polygons_size() const;
  public:
  void clear_polygons();
  ::task_worker::Polygon* mutable_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::Polygon >*
      mutable_polygons();
  private:
  const ::task_worker::Polygon& _internal_polygons(int index) const;
  ::task_worker::Polygon* _internal_add_polygons();
  public:
  const ::task_worker::Polygon& polygons(int index) const;
  ::task_worker::Polygon* add_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::Polygon >&
      polygons() const;

  // @@protoc_insertion_point(class_scope:task_worker.PolygonResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::Polygon > polygons_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_task_5fworker_2eproto;
};
// -------------------------------------------------------------------

class TaskResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:task_worker.TaskResponse) */ {
 public:
  inline TaskResponse() : TaskResponse(nullptr) {};
  virtual ~TaskResponse();

  TaskResponse(const TaskResponse& from);
  TaskResponse(TaskResponse&& from) noexcept
    : TaskResponse() {
    *this = ::std::move(from);
  }

  inline TaskResponse& operator=(const TaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResponse& operator=(TaskResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TaskResponse& default_instance();

  enum ResultCase {
    kPolygons = 1,
    RESULT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskResponse* internal_default_instance() {
    return reinterpret_cast<const TaskResponse*>(
               &_TaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TaskResponse& a, TaskResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskResponse* New() const final {
    return CreateMaybeMessage<TaskResponse>(nullptr);
  }

  TaskResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TaskResponse& from);
  void MergeFrom(const TaskResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "task_worker.TaskResponse";
  }
  protected:
  explicit TaskResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_task_5fworker_2eproto);
    return ::descriptor_table_task_5fworker_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonsFieldNumber = 1,
  };
  // .task_worker.PolygonResult polygons = 1;
  bool has_polygons() const;
  private:
  bool _internal_has_polygons() const;
  public:
  void clear_polygons();
  const ::task_worker::PolygonResult& polygons() const;
  ::task_worker::PolygonResult* release_polygons();
  ::task_worker::PolygonResult* mutable_polygons();
  void set_allocated_polygons(::task_worker::PolygonResult* polygons);
  private:
  const ::task_worker::PolygonResult& _internal_polygons() const;
  ::task_worker::PolygonResult* _internal_mutable_polygons();
  public:
  void unsafe_arena_set_allocated_polygons(
      ::task_worker::PolygonResult* polygons);
  ::task_worker::PolygonResult* unsafe_arena_release_polygons();

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:task_worker.TaskResponse)
 private:
  class _Internal;
  void set_has_polygons();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResultUnion {
    ResultUnion() {}
    ::task_worker::PolygonResult* polygons_;
  } result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_task_5fworker_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GeoPoint

// float lat = 1;
inline void GeoPoint::clear_lat() {
  lat_ = 0;
}
inline float GeoPoint::_internal_lat() const {
  return lat_;
}
inline float GeoPoint::lat() const {
  // @@protoc_insertion_point(field_get:task_worker.GeoPoint.lat)
  return _internal_lat();
}
inline void GeoPoint::_internal_set_lat(float value) {
  
  lat_ = value;
}
inline void GeoPoint::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:task_worker.GeoPoint.lat)
}

// float lng = 2;
inline void GeoPoint::clear_lng() {
  lng_ = 0;
}
inline float GeoPoint::_internal_lng() const {
  return lng_;
}
inline float GeoPoint::lng() const {
  // @@protoc_insertion_point(field_get:task_worker.GeoPoint.lng)
  return _internal_lng();
}
inline void GeoPoint::_internal_set_lng(float value) {
  
  lng_ = value;
}
inline void GeoPoint::set_lng(float value) {
  _internal_set_lng(value);
  // @@protoc_insertion_point(field_set:task_worker.GeoPoint.lng)
}

// float value = 3;
inline void GeoPoint::clear_value() {
  value_ = 0;
}
inline float GeoPoint::_internal_value() const {
  return value_;
}
inline float GeoPoint::value() const {
  // @@protoc_insertion_point(field_get:task_worker.GeoPoint.value)
  return _internal_value();
}
inline void GeoPoint::_internal_set_value(float value) {
  
  value_ = value;
}
inline void GeoPoint::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:task_worker.GeoPoint.value)
}

// -------------------------------------------------------------------

// TaskRequest

// repeated .task_worker.GeoPoint points = 1;
inline int TaskRequest::_internal_points_size() const {
  return points_.size();
}
inline int TaskRequest::points_size() const {
  return _internal_points_size();
}
inline void TaskRequest::clear_points() {
  points_.Clear();
}
inline ::task_worker::GeoPoint* TaskRequest::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:task_worker.TaskRequest.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >*
TaskRequest::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:task_worker.TaskRequest.points)
  return &points_;
}
inline const ::task_worker::GeoPoint& TaskRequest::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::task_worker::GeoPoint& TaskRequest::points(int index) const {
  // @@protoc_insertion_point(field_get:task_worker.TaskRequest.points)
  return _internal_points(index);
}
inline ::task_worker::GeoPoint* TaskRequest::_internal_add_points() {
  return points_.Add();
}
inline ::task_worker::GeoPoint* TaskRequest::add_points() {
  // @@protoc_insertion_point(field_add:task_worker.TaskRequest.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >&
TaskRequest::points() const {
  // @@protoc_insertion_point(field_list:task_worker.TaskRequest.points)
  return points_;
}

// .task_worker.TaskType task_type = 2;
inline void TaskRequest::clear_task_type() {
  task_type_ = 0;
}
inline ::task_worker::TaskType TaskRequest::_internal_task_type() const {
  return static_cast< ::task_worker::TaskType >(task_type_);
}
inline ::task_worker::TaskType TaskRequest::task_type() const {
  // @@protoc_insertion_point(field_get:task_worker.TaskRequest.task_type)
  return _internal_task_type();
}
inline void TaskRequest::_internal_set_task_type(::task_worker::TaskType value) {
  
  task_type_ = value;
}
inline void TaskRequest::set_task_type(::task_worker::TaskType value) {
  _internal_set_task_type(value);
  // @@protoc_insertion_point(field_set:task_worker.TaskRequest.task_type)
}

// -------------------------------------------------------------------

// Polygon

// repeated .task_worker.GeoPoint vertices = 1;
inline int Polygon::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Polygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline ::task_worker::GeoPoint* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:task_worker.Polygon.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:task_worker.Polygon.vertices)
  return &vertices_;
}
inline const ::task_worker::GeoPoint& Polygon::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::task_worker::GeoPoint& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:task_worker.Polygon.vertices)
  return _internal_vertices(index);
}
inline ::task_worker::GeoPoint* Polygon::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::task_worker::GeoPoint* Polygon::add_vertices() {
  // @@protoc_insertion_point(field_add:task_worker.Polygon.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::GeoPoint >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:task_worker.Polygon.vertices)
  return vertices_;
}

// float area = 2;
inline void Polygon::clear_area() {
  area_ = 0;
}
inline float Polygon::_internal_area() const {
  return area_;
}
inline float Polygon::area() const {
  // @@protoc_insertion_point(field_get:task_worker.Polygon.area)
  return _internal_area();
}
inline void Polygon::_internal_set_area(float value) {
  
  area_ = value;
}
inline void Polygon::set_area(float value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:task_worker.Polygon.area)
}

// -------------------------------------------------------------------

// PolygonResult

// repeated .task_worker.Polygon polygons = 1;
inline int PolygonResult::_internal_polygons_size() const {
  return polygons_.size();
}
inline int PolygonResult::polygons_size() const {
  return _internal_polygons_size();
}
inline void PolygonResult::clear_polygons() {
  polygons_.Clear();
}
inline ::task_worker::Polygon* PolygonResult::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:task_worker.PolygonResult.polygons)
  return polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::Polygon >*
PolygonResult::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:task_worker.PolygonResult.polygons)
  return &polygons_;
}
inline const ::task_worker::Polygon& PolygonResult::_internal_polygons(int index) const {
  return polygons_.Get(index);
}
inline const ::task_worker::Polygon& PolygonResult::polygons(int index) const {
  // @@protoc_insertion_point(field_get:task_worker.PolygonResult.polygons)
  return _internal_polygons(index);
}
inline ::task_worker::Polygon* PolygonResult::_internal_add_polygons() {
  return polygons_.Add();
}
inline ::task_worker::Polygon* PolygonResult::add_polygons() {
  // @@protoc_insertion_point(field_add:task_worker.PolygonResult.polygons)
  return _internal_add_polygons();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::task_worker::Polygon >&
PolygonResult::polygons() const {
  // @@protoc_insertion_point(field_list:task_worker.PolygonResult.polygons)
  return polygons_;
}

// -------------------------------------------------------------------

// TaskResponse

// .task_worker.PolygonResult polygons = 1;
inline bool TaskResponse::_internal_has_polygons() const {
  return result_case() == kPolygons;
}
inline bool TaskResponse::has_polygons() const {
  return _internal_has_polygons();
}
inline void TaskResponse::set_has_polygons() {
  _oneof_case_[0] = kPolygons;
}
inline void TaskResponse::clear_polygons() {
  if (_internal_has_polygons()) {
    if (GetArena() == nullptr) {
      delete result_.polygons_;
    }
    clear_has_result();
  }
}
inline ::task_worker::PolygonResult* TaskResponse::release_polygons() {
  // @@protoc_insertion_point(field_release:task_worker.TaskResponse.polygons)
  if (_internal_has_polygons()) {
    clear_has_result();
      ::task_worker::PolygonResult* temp = result_.polygons_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    result_.polygons_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::task_worker::PolygonResult& TaskResponse::_internal_polygons() const {
  return _internal_has_polygons()
      ? *result_.polygons_
      : *reinterpret_cast< ::task_worker::PolygonResult*>(&::task_worker::_PolygonResult_default_instance_);
}
inline const ::task_worker::PolygonResult& TaskResponse::polygons() const {
  // @@protoc_insertion_point(field_get:task_worker.TaskResponse.polygons)
  return _internal_polygons();
}
inline ::task_worker::PolygonResult* TaskResponse::unsafe_arena_release_polygons() {
  // @@protoc_insertion_point(field_unsafe_arena_release:task_worker.TaskResponse.polygons)
  if (_internal_has_polygons()) {
    clear_has_result();
    ::task_worker::PolygonResult* temp = result_.polygons_;
    result_.polygons_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TaskResponse::unsafe_arena_set_allocated_polygons(::task_worker::PolygonResult* polygons) {
  clear_result();
  if (polygons) {
    set_has_polygons();
    result_.polygons_ = polygons;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:task_worker.TaskResponse.polygons)
}
inline ::task_worker::PolygonResult* TaskResponse::_internal_mutable_polygons() {
  if (!_internal_has_polygons()) {
    clear_result();
    set_has_polygons();
    result_.polygons_ = CreateMaybeMessage< ::task_worker::PolygonResult >(GetArena());
  }
  return result_.polygons_;
}
inline ::task_worker::PolygonResult* TaskResponse::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable:task_worker.TaskResponse.polygons)
  return _internal_mutable_polygons();
}

inline bool TaskResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void TaskResponse::clear_has_result() {
  _oneof_case_[0] = RESULT_NOT_SET;
}
inline TaskResponse::ResultCase TaskResponse::result_case() const {
  return TaskResponse::ResultCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace task_worker

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::task_worker::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::task_worker::TaskType>() {
  return ::task_worker::TaskType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_task_5fworker_2eproto
